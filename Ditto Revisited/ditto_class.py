import random
def generate_pokemon(names, powers):
    """ use dictionary to easily generate the information of pokemons """
    list = {'name':random.choice(names), 'power':random.choice(powers), 'level':random.randint(1,10)}
    return list

class Ditto:
    """ use class to implement the whole assignment """
    def __init__(self):
        """ create ditto using class instead of dictionary """
        self.power=['absorb']
        self.count=0
        self.level=[1]
    def get_level(self):
        """ calculate the current level of ditto """
        sum_level=0 # give the sum_level a value
        for n in self.level: # use for loop to loop throught all the values in level
            sum_level= sum_level + n
        current_level = float(sum_level)/ float((self.count + 1)) #according to the instructions of the question
        return current_level

    def should_absorb(self,pokemon):
        """ compare the current_level and future_level """
        current_level = self.get_level #get the current_level from get_level(ditto)
        sum_level2 = sum(self.level) + pokemon['level'] #sum of current_level
        future_level = float(sum_level2) / float (self.count + 2) #average of the current_level
        if future_level > current_level: #make comparasion
            return True
        else:
            return False

    def absorb(self,pokemon):
        """ use append to absorb new pokemon """
        self.level.append(pokemon['level'])
        self.count += 1 #the count should increase one unit
        self.power.append(pokemon['power'])

def take_walk(pokemon_list):
    """ create the initial ditto and then according to different situations
        to decide whether or not to absorb the new pokemon
    """
    ditto = Ditto()
    for index in range(len(pokemon_list)): #start to loop every pokemon the pokemon_list generates
        if ditto.should_absorb(pokemon_list[index]) == True: #if the new pokemon increase the ability of ditto
          ditto.absorb(pokemon_list[index])
        elif pokemon_list[index]['power'] not in ditto.power: #if ditto does not have the power generated by the new pokemon
          ditto.absorb(pokemon_list[index])
    return ditto
